\hypertarget{namespaceln__space}{}\section{ln\+\_\+space Namespace Reference}
\label{namespaceln__space}\index{ln\+\_\+space@{ln\+\_\+space}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$int dim$>$ }\\void \hyperlink{namespaceln__space_a85e361462746b126386ad7e1d608e7d8}{pre\+\_\+ln} (Tensor$<$ 2, dim $>$ \&F, Symmetric\+Tensor$<$ 2, dim $>$ \&hencky\+\_\+strain, Vector$<$ double $>$ \&ea, Vector$<$ double $>$ \&da, Vector$<$ double $>$ \&fa, std\+::vector$<$ Tensor$<$ 1, dim $>$ $>$ \&eigenvector, Vector$<$ double $>$ \&eigenvalues, std\+::vector$<$ Symmetric\+Tensor$<$ 2, dim $>$ $>$ \&eigenbasis)
\item 
{\footnotesize template$<$int dim$>$ }\\void \hyperlink{namespaceln__space_a0f5e3bde0b1ee47f3dbc5977b4653342}{post\+\_\+ln} (Vector$<$ double $>$ \&ea, Vector$<$ double $>$ \&da, Vector$<$ double $>$ \&fa, Vector$<$ double $>$ \&eigenvalues, std\+::vector$<$ Symmetric\+Tensor$<$ 2, dim $>$ $>$ \&eigenbasis, Symmetric\+Tensor$<$ 2, dim $>$ \&second\+\_\+piola\+\_\+stress\+\_\+S, Symmetric\+Tensor$<$ 4, dim $>$ \&elasto\+\_\+plastic\+\_\+tangent)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{ln\+\_\+space@{ln\+\_\+space}!post\+\_\+ln@{post\+\_\+ln}}
\index{post\+\_\+ln@{post\+\_\+ln}!ln\+\_\+space@{ln\+\_\+space}}
\subsubsection[{\texorpdfstring{post\+\_\+ln(\+Vector$<$ double $>$ \&ea, Vector$<$ double $>$ \&da, Vector$<$ double $>$ \&fa, Vector$<$ double $>$ \&eigenvalues, std\+::vector$<$ Symmetric\+Tensor$<$ 2, dim $>$ $>$ \&eigenbasis, Symmetric\+Tensor$<$ 2, dim $>$ \&second\+\_\+piola\+\_\+stress\+\_\+\+S, Symmetric\+Tensor$<$ 4, dim $>$ \&elasto\+\_\+plastic\+\_\+tangent)}{post_ln(Vector< double > &ea, Vector< double > &da, Vector< double > &fa, Vector< double > &eigenvalues, std::vector< SymmetricTensor< 2, dim > > &eigenbasis, SymmetricTensor< 2, dim > &second_piola_stress_S, SymmetricTensor< 4, dim > &elasto_plastic_tangent)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$int dim$>$ void ln\+\_\+space\+::post\+\_\+ln (
\begin{DoxyParamCaption}
\item[{Vector$<$ double $>$ \&}]{ea, }
\item[{Vector$<$ double $>$ \&}]{da, }
\item[{Vector$<$ double $>$ \&}]{fa, }
\item[{Vector$<$ double $>$ \&}]{eigenvalues, }
\item[{std\+::vector$<$ Symmetric\+Tensor$<$ 2, dim $>$ $>$ \&}]{eigenbasis, }
\item[{Symmetric\+Tensor$<$ 2, dim $>$ \&}]{second\+\_\+piola\+\_\+stress\+\_\+S, }
\item[{Symmetric\+Tensor$<$ 4, dim $>$ \&}]{elasto\+\_\+plastic\+\_\+tangent}
\end{DoxyParamCaption}
)}\hypertarget{namespaceln__space_a0f5e3bde0b1ee47f3dbc5977b4653342}{}\label{namespaceln__space_a0f5e3bde0b1ee47f3dbc5977b4653342}


References get\+\_\+tensor\+\_\+operator\+\_\+\+F\+\_\+left(), get\+\_\+tensor\+\_\+operator\+\_\+\+F\+\_\+right(), get\+\_\+tensor\+\_\+operator\+\_\+\+G(), symmetrize(), and symmetry\+\_\+check().


\begin{DoxyCode}
87     \{
88         \textcolor{keyword}{const} \textcolor{keywordtype}{double} comp\_tolerance = 1e-8;
89         SymmetricTensor<2,dim> stress\_measure\_T\_sym = second\_piola\_stress\_S; \textcolor{comment}{// the output argument is
       abused as an input argument}
90 
91         \textcolor{comment}{/*}
92 \textcolor{comment}{         * 3. Set up coefficients \(\backslash\)a theta, \(\backslash\)a xi and \(\backslash\)a eta}
93 \textcolor{comment}{         */}
94     
95         \textcolor{comment}{// Compute the coefficients based on the eigenvalues, eigenvectors and ea,da,fa}
96          Tensor<2, dim> theta;
97          Tensor<2, dim> xi;
98          \textcolor{keywordtype}{double} eta = 999999999.0;
99     
100         \textcolor{comment}{// For three different eigenvalues \(\backslash\)f$ \(\backslash\)lambda\_a \(\backslash\)neq \(\backslash\)lambda\_b \(\backslash\)neq \(\backslash\)lambda\_c \(\backslash\)f$}
101          \textcolor{keywordflow}{if} (
102                  ( !(std::fabs(eigenvalues(0) - eigenvalues(1)) < comp\_tolerance) )
103                  &&
104                  ( !(std::fabs(eigenvalues(0) - eigenvalues(2)) < comp\_tolerance) )
105                  &&
106                  ( !(std::fabs(eigenvalues(1) - eigenvalues(2)) < comp\_tolerance) )
107              )
108          \{
109             eta = 0.0;
110             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} a = 0; a < dim; ++a)
111                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} b = 0; b < dim; ++b)
112                     \textcolor{keywordflow}{if} (a != b)
113                     \{
114                         theta[a][b] = (ea(a) - ea(b))
115                                       / (eigenvalues(a) - eigenvalues(b));
116                         xi[a][b] = (theta[a][b] - 0.5 * da(b))
117                                    / (eigenvalues(a) - eigenvalues(b));
118     
119                         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} c = 0; c < dim; ++c)
120                             \textcolor{keywordflow}{if} ((c != a) && (c != b))
121                             \{
122                                 eta +=
123                                         ea(a)
124                                         / (2.0
125                                            * (eigenvalues(a)
126                                               - eigenvalues(b))
127                                            * (eigenvalues(a)
128                                               - eigenvalues(c)));
129                             \}
130                     \}
131          \}
132         \textcolor{comment}{//  For three equal eigenvalues \(\backslash\)f$ \(\backslash\)lambda\_a = \(\backslash\)lambda\_b = \(\backslash\)lambda\_c \(\backslash\)f$}
133          \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( (std::fabs(eigenvalues(0) - eigenvalues(1)) < comp\_tolerance)
134                     &&
135                    (std::fabs(eigenvalues(1) - eigenvalues(2)) < comp\_tolerance) )
136          \{
137             eta = 0.0;
138             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} a = 0; a < dim; ++a)
139             \{
140                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} b = 0; b < dim; ++b)
141                     \textcolor{keywordflow}{if} (a != b)
142                     \{
143                         theta[a][b] = 0.5 * da(0);
144                         xi[a][b] = (1.0 / 8.0) * fa(0);
145                     \}
146             \}
147             eta = (1.0 / 8.0) * fa(0);
148          \}
149     
150         \textcolor{comment}{// For two equal eigenvalues a and b: \(\backslash\)f$ \(\backslash\)lambda\_a = \(\backslash\)lambda\_b \(\backslash\)neq \(\backslash\)lambda\_c \(\backslash\)f$}
151          \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( (std::fabs(eigenvalues(0) - eigenvalues(1)) < comp\_tolerance)
152                    &&
153                    ( !(std::fabs(eigenvalues(1) - eigenvalues(2)) < comp\_tolerance) ) )
154          \{
155             eta = 0.0;
156             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} a = 0; a < dim; ++a)
157                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} b = 0; b < dim; ++b)
158                     \textcolor{keywordflow}{if} ((a != b) && ((a == 2) || (b == 2)))
159                     \{
160                         theta[a][b] = (ea(a) - ea(b))
161                                       / (eigenvalues(a) - eigenvalues(b));
162                         xi[a][b] = (theta[a][b] - 0.5 * da(b))
163                                    / (eigenvalues(a) - eigenvalues(b));
164                     \}
165     
166             theta[0][1] = 0.5 * da(0);
167             theta[1][0] = theta[0][1];
168             xi[0][1] = (1.0 / 8.0) * fa(0);
169             xi[1][0] = xi[0][1];
170             eta = xi[2][0];
171          \}
172         \textcolor{comment}{// For two equal eigenvalues a and c: \(\backslash\)f$ \(\backslash\)lambda\_a = \(\backslash\)lambda\_c \(\backslash\)neq \(\backslash\)lambda\_b \(\backslash\)f$}
173          \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( (std::fabs(eigenvalues(0) - eigenvalues(2)) < comp\_tolerance)
174                    &&
175                    (!(std::fabs(eigenvalues(1) - eigenvalues(2)) < comp\_tolerance)) )
176          \{
177             eta = 0.0;
178             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} a = 0; a < dim; ++a)
179                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} b = 0; b < dim; ++b)
180                     \textcolor{keywordflow}{if} ( (a != b) && ((a == 1) || (b == 1)) )
181                     \{
182                         theta[a][b] = (ea(a) - ea(b))
183                                       / (eigenvalues(a) - eigenvalues(b));
184                         xi[a][b] = (theta[a][b] - 0.5 * da(b))
185                                    / (eigenvalues(a) - eigenvalues(b));
186                     \}
187     
188             theta[0][2] = 0.5 * da(0);
189             theta[2][0] = theta[0][2];
190             xi[0][2] = (1.0 / 8.0) * fa(0);
191             xi[2][0] = xi[0][2];
192             eta = xi[1][0];
193          \}
194         \textcolor{comment}{// For two equal eigenvalues b and c: \(\backslash\)f$ \(\backslash\)lambda\_b = \(\backslash\)lambda\_c \(\backslash\)neq \(\backslash\)lambda\_a \(\backslash\)f$}
195          \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( (std::fabs(eigenvalues(1) - eigenvalues(2)) < comp\_tolerance)
196                    &&
197                    (!(std::fabs(eigenvalues(0) - eigenvalues(1)) < comp\_tolerance)) )
198          \{
199             eta = 0.0;
200             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} a = 0; a < dim; ++a)
201                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} b = 0; b < dim; ++b)
202                     \textcolor{keywordflow}{if} ( (a != b) && ((a == 0) || (b == 0)) )
203                     \{
204                         theta[a][b] = (ea(a) - ea(b))
205                                       / (eigenvalues(a) - eigenvalues(b));
206                         xi[a][b] = (theta[a][b] - 0.5 * da(b))
207                                    / (eigenvalues(a) - eigenvalues(b));
208                     \}
209     
210             theta[1][2] = 0.5 * da(1);
211             theta[2][1] = theta[1][2];
212             xi[1][2] = (1.0 / 8.0) * fa(1);
213             xi[2][1] = xi[1][2];
214             eta = xi[0][1];
215          \}
216          \textcolor{keywordflow}{else}
217          \{
218             deallog << \textcolor{stringliteral}{"ln-space<< eigenvalues:0: "} << eigenvalues[0] << std::endl;
219             deallog << \textcolor{stringliteral}{"ln-space<< eigenvalues:1: "} << eigenvalues[1] << std::endl;
220             deallog << \textcolor{stringliteral}{"ln-space<< eigenvalues:2: "} << eigenvalues[2] << std::endl;
221             AssertThrow( \textcolor{keyword}{false},
222                          ExcMessage(\textcolor{stringliteral}{"ln-space<< Eigenvalue case not possible, check update\_qph!"}) );
223          \}
224     
225         \textcolor{comment}{// Ensure that \(\backslash\)a eta was initialised in one of the cases}
226          AssertThrow( (eta < 9999999), ExcMessage(\textcolor{stringliteral}{"Eta in update\_qph not initialised"}) );
227     
228     
229         \textcolor{comment}{/*}
230 \textcolor{comment}{         * 4. Lagrangian stresses and elasticity moduli}
231 \textcolor{comment}{         */}
232     
233         \textcolor{comment}{// Compute projection tensor P}
234          Tensor<4, dim> projection\_tensor\_P;
235          \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} a = 0; a < dim; ++a)
236          \{
237             projection\_tensor\_P += da(a) * (Tensor<4,dim> ) outer\_product(eigenbasis[a],eigenbasis[a]);
238             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} b = 0; b < dim; ++b)
239                 \textcolor{keywordflow}{if} (b != a)
240                     projection\_tensor\_P += theta[a][b] * \hyperlink{functions_8h_a6e649771188b6d625bea6309e77fbd16}{get\_tensor\_operator\_G}(
      eigenbasis[a],eigenbasis[b]);
241          \}
242     
243         \textcolor{comment}{// Check whether the projecton tensor is symmetric and store it into a \(\backslash\)a SymmetricTensor}
244          AssertThrow( \hyperlink{functions_8h_aa37f13547b984cb066e2fcb530b36425}{symmetry\_check}(projection\_tensor\_P), ExcMessage( \textcolor{stringliteral}{"ln-space<< Projection
       tensor P is not symmetric"}) );
245          SymmetricTensor<4,dim> projection\_tensor\_P\_sym = \hyperlink{functions_8h_afe83e9509497294b7f662b800b6b91ff}{symmetrize}(projection\_tensor\_P);
246     
247         \textcolor{comment}{// Compute the double contraction of T and L}
248          Tensor<4, dim> projection\_tensor\_T\_doublecon\_L;
249          \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} a = 0; a < dim; ++a)
250          \{
251             projection\_tensor\_T\_doublecon\_L += fa(a)
252                                                * (stress\_measure\_T\_sym * eigenbasis[a])
253                                                * (Tensor<4, dim> ) (outer\_product(eigenbasis[a], eigenbasis
      [a]));
254             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} b = 0; b < dim; ++b)
255                 \textcolor{keywordflow}{if} (b != a)
256                 \{
257                     projection\_tensor\_T\_doublecon\_L += 2.0 * xi[a][b]
258                                                        * (
259                                                             
      \hyperlink{functions_8h_acfd8da38df3766246f7bcf0e736ad9f4}{get\_tensor\_operator\_F\_right}( eigenbasis[a], eigenbasis[b], eigenbasis[b], 
      stress\_measure\_T\_sym )
260                                                           + 
      \hyperlink{functions_8h_a6f9435c7728281851248d3537c100e7d}{get\_tensor\_operator\_F\_left}(  eigenbasis[a], eigenbasis[b], eigenbasis[b], 
      stress\_measure\_T\_sym )
261                                                           + 
      \hyperlink{functions_8h_acfd8da38df3766246f7bcf0e736ad9f4}{get\_tensor\_operator\_F\_right}( eigenbasis[b], eigenbasis[b], eigenbasis[a], 
      stress\_measure\_T\_sym )
262                                                           + 
      \hyperlink{functions_8h_a6f9435c7728281851248d3537c100e7d}{get\_tensor\_operator\_F\_left}(  eigenbasis[b], eigenbasis[b], eigenbasis[a], 
      stress\_measure\_T\_sym )
263                                                           + 
      \hyperlink{functions_8h_acfd8da38df3766246f7bcf0e736ad9f4}{get\_tensor\_operator\_F\_right}( eigenbasis[b], eigenbasis[a], eigenbasis[b], 
      stress\_measure\_T\_sym )
264                                                           + 
      \hyperlink{functions_8h_a6f9435c7728281851248d3537c100e7d}{get\_tensor\_operator\_F\_left}(  eigenbasis[b], eigenbasis[a], eigenbasis[b], 
      stress\_measure\_T\_sym )
265                                                          );
266     
267                     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} c = 0; c < dim; ++c)
268                         \textcolor{keywordflow}{if} ( (c != a) && (c != b) )
269                         \{
270                             projection\_tensor\_T\_doublecon\_L += 2.0 * eta
271                                                                * (
272                                                                       
      \hyperlink{functions_8h_acfd8da38df3766246f7bcf0e736ad9f4}{get\_tensor\_operator\_F\_right}( eigenbasis[a], eigenbasis[b], eigenbasis[c], 
      stress\_measure\_T\_sym )
273                                                                     + 
      \hyperlink{functions_8h_a6f9435c7728281851248d3537c100e7d}{get\_tensor\_operator\_F\_left}(  eigenbasis[b], eigenbasis[c], eigenbasis[a], 
      stress\_measure\_T\_sym )
274                                                                   );
275                         \}
276                 \}
277          \}
278     
279         \textcolor{comment}{// Check whether the tensor is symmetric and store it into a \(\backslash\)a SymmetricTensor}
280          AssertThrow( \hyperlink{functions_8h_aa37f13547b984cb066e2fcb530b36425}{symmetry\_check}(projection\_tensor\_T\_doublecon\_L),
281                       ExcMessage(\textcolor{stringliteral}{"ln-space<< Projection tensor T:L is not symmetric"}) );
282          SymmetricTensor<4,dim> projection\_tensor\_T\_doublecon\_L\_sym = \hyperlink{functions_8h_afe83e9509497294b7f662b800b6b91ff}{symmetrize}(
      projection\_tensor\_T\_doublecon\_L);
283     
284         \textcolor{comment}{// Compute the retransformed values}
285          second\_piola\_stress\_S = stress\_measure\_T\_sym * projection\_tensor\_P\_sym;
286     
287          elasto\_plastic\_tangent = projection\_tensor\_P\_sym * elasto\_plastic\_tangent * 
      projection\_tensor\_P\_sym \textcolor{comment}{// Note: we work on the input argument \(\backslash\)a elasto\_plastic\_tangent}
288                                   + projection\_tensor\_T\_doublecon\_L\_sym;
289     \}
\end{DoxyCode}
\index{ln\+\_\+space@{ln\+\_\+space}!pre\+\_\+ln@{pre\+\_\+ln}}
\index{pre\+\_\+ln@{pre\+\_\+ln}!ln\+\_\+space@{ln\+\_\+space}}
\subsubsection[{\texorpdfstring{pre\+\_\+ln(\+Tensor$<$ 2, dim $>$ \&\+F, Symmetric\+Tensor$<$ 2, dim $>$ \&hencky\+\_\+strain, Vector$<$ double $>$ \&ea, Vector$<$ double $>$ \&da, Vector$<$ double $>$ \&fa, std\+::vector$<$ Tensor$<$ 1, dim $>$ $>$ \&eigenvector, Vector$<$ double $>$ \&eigenvalues, std\+::vector$<$ Symmetric\+Tensor$<$ 2, dim $>$ $>$ \&eigenbasis)}{pre_ln(Tensor< 2, dim > &F, SymmetricTensor< 2, dim > &hencky_strain, Vector< double > &ea, Vector< double > &da, Vector< double > &fa, std::vector< Tensor< 1, dim > > &eigenvector, Vector< double > &eigenvalues, std::vector< SymmetricTensor< 2, dim > > &eigenbasis)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$int dim$>$ void ln\+\_\+space\+::pre\+\_\+ln (
\begin{DoxyParamCaption}
\item[{Tensor$<$ 2, dim $>$ \&}]{F, }
\item[{Symmetric\+Tensor$<$ 2, dim $>$ \&}]{hencky\+\_\+strain, }
\item[{Vector$<$ double $>$ \&}]{ea, }
\item[{Vector$<$ double $>$ \&}]{da, }
\item[{Vector$<$ double $>$ \&}]{fa, }
\item[{std\+::vector$<$ Tensor$<$ 1, dim $>$ $>$ \&}]{eigenvector, }
\item[{Vector$<$ double $>$ \&}]{eigenvalues, }
\item[{std\+::vector$<$ Symmetric\+Tensor$<$ 2, dim $>$ $>$ \&}]{eigenbasis}
\end{DoxyParamCaption}
)}\hypertarget{namespaceln__space_a85e361462746b126386ad7e1d608e7d8}{}\label{namespaceln__space_a85e361462746b126386ad7e1d608e7d8}


References symmetrize().


\begin{DoxyCode}
24     \{
25         \textcolor{comment}{// Following "Algorithms for computation of stresses and elasticity moduli in terms of Seth–Hill’s
       family of generalized strain tensors" by Miehe&Lambrecht \(\backslash\)n}
26         \textcolor{comment}{// Table I. Algorithm A}
27         \textcolor{comment}{/*}
28 \textcolor{comment}{         * 1. Eigenvalues, eigenvalue bases and diagonal functions:}
29 \textcolor{comment}{         */}
30     
31         \textcolor{comment}{// Get the symmetric right cauchy green tensor}
32          SymmetricTensor<2, dim> right\_cauchy\_green\_sym = \hyperlink{functions_8h_afe83e9509497294b7f662b800b6b91ff}{symmetrize}( transpose(F) * F);\textcolor{comment}{//
      Physics::Elasticity::Kinematics::C(F);}
33     
34         \textcolor{comment}{// Compute Eigenvalues, Eigenvectors and Eigenbasis}
35          \{
36             \textcolor{comment}{// Get Eigenvalues and Eigenvectors from the deal.ii function \(\backslash\)a eigenvectors(*)}
37             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0; i < dim; ++i) \{
38                 eigenvalues[i] = eigenvectors(right\_cauchy\_green\_sym)[i].first;
39                 eigenvector[i] = eigenvectors(right\_cauchy\_green\_sym)[i].second;
40             \}
41     
42             \textcolor{comment}{// Check if the found eigenvectors are perpendicular to each other}
43             \textcolor{keywordflow}{if} ((std::fabs(eigenvalues(0) - 1) > 1e-10)
44                 && (std::fabs(eigenvalues(1) - 1) > 1e-10)
45                 && (std::fabs(eigenvalues(2) - 1) > 1e-10)) \{
46                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0; i < dim; ++i) \{
47                     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j = i + 1; j < dim; ++j) \{
48                         AssertThrow( (std::fabs(eigenvector[i] * eigenvector[j]) < 1e-12),
49                                      ExcMessage(\textcolor{stringliteral}{"ln-space<< Eigenvectors are not perpendicular to each
       other."}) );
50                     \}
51                 \}
52             \}
53     
54             \textcolor{comment}{// Compute eigenbasis Ma: eigenbasis = eigenvector \(\backslash\)otimes eigenvector}
55             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0; i < dim; ++i) \{
56                 eigenbasis[i] = \hyperlink{functions_8h_afe83e9509497294b7f662b800b6b91ff}{symmetrize}( outer\_product(eigenvector[i], eigenvector[i]) );
57                 AssertThrow( eigenvalues(i) >= 0.0,
58                              ExcMessage(\textcolor{stringliteral}{"ln-space<< Eigenvalue is negativ. Check update\_qph."}) );
59             \}
60          \}
61     
62         \textcolor{comment}{// Compute diagonal function \(\backslash\)a ea and its first and second derivate \(\backslash\)a da and \(\backslash\)a fa \(\backslash\)n}
63          \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0; i < dim; ++i)
64          \{
65             ea(i) = 0.5 * std::log( std::abs(eigenvalues(i)) ); \textcolor{comment}{// diagonal function}
66             da(i) = std::pow(eigenvalues(i), -1.0);             \textcolor{comment}{// first derivative of diagonal function ea}
67             fa(i) = -2.0 * std::pow(eigenvalues(i), -2.0);          \textcolor{comment}{// second derivative of diagonal
       function ea}
68             AssertThrow( ea(i) == ea(i),
69                          ExcMessage( \textcolor{stringliteral}{"ln-space<< Ea is nan due to logarithm of negativ eigenvalue. Check
       update\_qph."}) );
70             AssertThrow( da(i) > 0.0,
71                          ExcMessage( \textcolor{stringliteral}{"ln-space<< First derivative da of diagonal function is "}+
      std::to\_string(da(i))+\textcolor{stringliteral}{" < 0.0 . Check update\_qph."}) );
72          \}
73     
74         \textcolor{comment}{// Compute the Hencky strain}
75          \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} a = 0; a < dim; ++a)
76             hencky\_strain += ea(a) * eigenbasis[a];
77          
78         \textcolor{comment}{// Output-> SymmetricTensor<2, dim> hencky\_strain, Vector<double> ea, da, fa,}
79         \textcolor{comment}{//          std::vector<Tensor<1, dim>> eigenvector, Vector<double> eigenvalues, std::vector<
       SymmetricTensor<2, dim> > eigenbasis}
80     \}
\end{DoxyCode}
